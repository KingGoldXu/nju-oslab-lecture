---
layout: post
title: Lab 03 @ 建设中
---

### Fork

我们的实验现在已经能够从内核中加载一个用户程序并运行了，
但是现实的内核是支持多个进程并发执行的，
那么我们如何执行第二个、第三个进程呢？
经典的方法是，内核只主动加载执行名为 init 的用户态程序，
这个程序根据配置好的启动脚本，进一步地创建新的进程，加载系统运行所需要的其他程序。
最终到达提供用户一个可以交互的 shell （终端或者桌面环境）。
此后便主要由用户输入来决定何时创建新的进程，以及加载哪个程序。

由于内核只会在启动时主动创建一个用户进程，而之后创建进程的行为由用户程序来进行决断，
所以我们需要在内核中提供创建进程的系统调用，这便是 fork。

下面我们来具体说下 fork 干了什么事。
粗略地来讲，fork 会创建一个新的进程，并将调用 fork 的进程（下面称作**父进程**）的资源拷贝过去。
具体哪些资源需要拷贝，哪些资源不需要 / 不能拷贝，这要看操作系统的具体策略，但是就目前的实验进度而言，
我们的进程拥有的下面这些资源是要拷贝的：

- 中断现场
- 地址空间映射（页目录，页表）
- 物理页的**内容**

这里涉及到浅拷贝和深拷贝的问题。简单地说，浅拷贝只复制引用关系，深拷贝复制所有内容，
下面这段代码是一个示例：

```c
char a[] = "Hello, World!";      // 一个隐含的深拷贝
const char *b = "Hello, World";  // 浅拷贝

char *c = a;                     // 浅拷贝，对 c 中元素的写操作会即对 a 中元素的写操作

char *d = malloc(sizeof(a));
strcpy(d, a);                    // 深拷贝
```

对于 fork，文件描述符、信号量这种本身属于引用型的资源不需要进一步的深拷贝，
但是我们现在还没有这些设施，可以说所有的内容都需要深拷贝，
内核栈、页目录、页表、物理页都需要开辟新的空间进行拷贝，而不能只改写指针。
特别地，对于页目录项和页表项，要填写新分配的页框号。
一个例外是只读页，由于它不会被写，多个进程使用同一个只读页不会产生竞争问题，
所以可以不为它分配新的物理页进行拷贝，而是直接使用原来的页框号填到新分配的页表里。

Fork 的另一个问题是内核栈。
由于新的进程有新的内核栈，所以如果你在内核栈存放了局部变量的地址，进行深拷贝后就会有引用问题。
不过这个问题有一些前置条件：

1. 发生了嵌套中断，这样在两个中断现场之间才会存在临时变量；
2. 你真的将临时变量的地址放到了栈上，这常见于将局部变量地址作为函数参数的场合。

一般来说，发生嵌套中断是可能的，但这往往是保护（General Protection）异常，
当然，还有在内核态开中断；
对于前者，我们没理由在出错的情况下进行 fork. 对于后者，虽然在内核态合适的场合开中断是现代操作系统的基本素养，
但是出于 KISS 原则的考虑，我们目前还是建议在整个内核态关闭硬件中断（这样的坏处是并发粒度太粗，响应延迟大）。

基于以上简化，其实我们没必要拷贝整个内核栈，只需要将父进程陷阱帧的内容放到子进程内核栈的顶部就可以了。

以上是 fork 的一些基本信息，下面明确一下为了实现 fork, 你需要做哪些事情：

1. 分配一个新的 PCB 并分配 PID。
怎么分配？可以创建一个固定大小的 PCB 数组，然后用下标做 PID。也可以像管理物理页那样，使用空闲链表进行优化。
你应该在实验二中设计说 PCB 的结构体，并且将内核栈以某种形式和 PCB 关联起来。
2. 分配新的页目录，并遍历父进程的页目录，将存在的页目录项复制，但是使用新分配的页表的物理地址来（所以其实只复制了属性……）。
对新分配的页表，递归地执行类似的操作。
3. 在子进程的内核栈顶复制父进程的陷阱帧，伪造中断现场。

Fork 并不要求先从父进程返回还是先从子进程返回。如何从进程 A 切换到进程 B，则是进程调度相关的内容。

#### 延生阅读

- 2012 级操作系统实验关于 fork 等系统调用的说明见[这里](http://114.212.10.6/ics/index.php/os:2012/lab3#fork)。
- 关于 Linux 下的 fork 系统调用，通过 `man fork` 了解。
- 查询 Wikipedia 和 OSDev 关于 fork 的词条。
- JOS 关于写时拷贝（Copy On Write, COW） fork 的介绍见[这里](https://pdos.csail.mit.edu/6.828/2014/labs/lab4/#Part-B--Copy-on-Write-Fork)。

下面是一个关于 fork 的趣味题（[来源](http://coolshell.cn/articles/7965.html)），可以帮助你进一步理解什么叫拷贝父进程的资源。

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
  int i;
  for (i = 0; i < 2; i++) {
    fork();
    printf("X");
  }
}
```

- 请问上面的代码会输出几个 `X` ？
- 如果给 `"X"` 加上换行符呢？
- ~~如果加上换行符并将输出重定向到文件呢？（这个和 fork 没关系了）~~

### Exit

Exit 系统调用用于销毁进程，它需要考虑的内容不多，只需要在代码层面实现物理页（相关的物理页信息，包含页表和页目录的）、
内核栈空间、PCB  以及其它一些资源的释放。PCB 的释放同时意味着将它从可调度进程集合中移除。

更多信息可参见 `man exit` 和 2012 级的相关内容（见上）。
