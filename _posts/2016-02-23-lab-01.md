---
layout: post
title: Lab 01
---

## 阶段 1 Boot loader 与 Hello World

### 系统启动

计算机加电后, 一些寄存器会被设置初值, 计算机将运行在实模式(real-address mode)下, 其中 CS:IP 指向 BIOS 的第一条指令, 即首先取得控制权的是 BIOS。 BIOS 将检查各部分硬件是否正常工作, 然后按照 CMOS RAM 中设置的启动设备查找顺序, 来寻找可启动设备。可启动设备的特征是：第一个扇区的末尾是一个约定了的魔数 0x55 和 0xaa， BIOS 会据此判定一个设备是否可启动。当然，你也可以把你喜欢的一张图片写到U盘上，然后把第 512 个字节处改为这个魔数来戏弄计算机（但是你不能把图片简单地拷贝到U盘上，你可以思考一下为什么，这也是 OS 课程的内容）。

BIOS确定第一个扇区是可启动的之后，便会执行 0x7c00 处的地址，执行你的程序了。不过不像 PA2 的testcases，一开始只能执行一些16进制的代码。

我们的实验使用的模拟器是 QEMU，是一个强大的模拟器，它可以模拟各种指令集的机器，而我们实验要用到的是 qemu-system-i386，这个程序和你们实现的 NEMU十分相似。相似之处有很多，比如段描述符和页表的结构是相同的、指令集是相同的，所以如果你还有对 PA 的印象，那么本次实验的很多部分对你来说将会很轻松。不同之处之一是 NEMU 的 PA2 实现的实地址模式的 32 位的指令集在历史上是不存在的，而QEMU较为真实地模拟了 i386，所以它对这些历史遗留问题也进行了模拟（你的PC也保留了这些）。我们要完成的汇编代码主要就是对这些历史遗留问题的解决。
遗留问题主要有 2 个：

1. 机器启动时使用的是实地址模式，而且只能执行 16 位的代码
2. A20 地址线问题

其中 A20 地址线问题的解决方法很简单的，这是 jos 中开启 A20 地址线的方法：

```Assembly
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -> port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -> port 0x60
  outb    %al,$0x60
```

第二个问题则是开启保护模式，这是在 PA 中进行过的工作。

上学期完成了 PA 之后，相信你对 x86 的虚拟存储管理有了较为深刻的认识。不过在 PA 中，你所实现的主要是 MMU，而在 OSLAB 中你不需要实现 MMU，而是为现有的 CPU 填写合适的段描述符（和页表）。
这是段描述符的结构（来自你们的 PA3 讲义，感谢 yzh 学长）：

```
DESCRIPTORS USED FOR APPLICATIONS CODE AND DATA SEGMENTS

31                23                15                7               0
+-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------+
|                 | | | |A|         | |     | |     | |                 |
|   BASE 31..24   |G|X|O|V| LIMIT   |P| DPL |1| TYPE|A|  BASE 23..16    | 4
|                 | | | |L| 19..16  | |     | |     | |                 |
|-----------------+-+-+-+-+---------+-+-----+-+-----+-+-----------------|
|                                   |                                   |
|        SEGMENT BASE 15..0         |       SEGMENT LIMIT 15..0         | 0
|                                   |                                   |
+-----------------------------------+-----------------------------------+

  A      - ACCESSED
  AVL    - AVAILABLE FOR USE BY SYSTEMS PROGRAMMERS
  DPL    - DESCRIPTOR PRIVILEGE LEVEL
  G      - GRANULARITY
  P      - SEGMENT PRESENT
```

要在 C 代码中实现段描述符，你可以很方便地使用位域结构体。而在汇编代码中你可以使用以下的宏来定义段描述符（来自 jos），你需要定义：代码段和数据段，前者是可执行但不可以写的，后者是可写的。

```c
#define SEG(type,base,lim)                                      \
    .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
    .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
        (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
```

GDT 是由段描述符组成的数组，在定义好启动时所使用的段描述符之后，用 lgdt 指令将 GDT 的首地址加载到 gdtr 中即可。
然后设置 cr0 中相应的字段，开启保护模式，紧接着便可以执行 32 位的汇编代码了，这个时候又会使用到一条熟悉的指令： ljmp 。为什么要用 ljmp？怎么用？请你回忆一下。
两个主要问题的解决方法介绍了，你在启动过程中还需要注意以下问题：

1. 第一条指令你应该关中断，想一想或者试一试不这样做会发生什么，为什么？
1. 复位“方向寄存器”，因为我们知道Intel为我们提供了movs这样的指令糖，让我们可以高效地实现成块数据的复制，而复制的方向则是由cld和std设置的。如果不这样做会不会有问题？你可以试一试。
1. 在开启保护模式之前用bios中断将显卡切换到图形模式，因为我们需要实现的是图形界面的游戏。你可以用`mov $0x0013, %ax`, `int $0x10`进入标准 VGA 模式(320 x 200 x 256色)有没有其他方法可以切换显卡的模式？
1. 将数据段寄存器清零，可不可以不清零？
1. 在进入32位模式后，为数据段寄存器（选择子）设置新的值，即你自己定义的数据段描述符在GDT中的偏移量。
1. 设置c代码的栈顶，接下来我们终于可以执行C代码了。

### Loader

在PA中你完成过loader，这里的loader和你以前完成的loader十分相似，如果你忘了ELF结构相关的知识，赶紧去读一读手册或者读一读你以前的代码。
不同之处在于，你在PA2中完成的loader实际上是从内存中将程序加载到另一段内存中，而在qemu中的“磁盘”不是内存，所以你不能简单地使用mov或者movs完成。你需要从磁盘中将elf header加载到内存中，然后进行解析，并加载剩下的部分。
磁盘IO可以在实模式下通过bios中断实现，也可以通过独立编编址的in和out指令实现。（什么是独立编址，什么是统一编址？）为了减轻工作量，我们从jos中copy过来的x86.h中提供了不少内联汇编的代码，其中包括了对in和out的封装，你可以直接拿来使用。关于内联汇编你需要理解2方面的内容：变量绑定和clobbers，参考资料：https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html
要实现磁盘IO，你还需要了解与磁盘读写相关的端口，在https://en.wikipedia.org/wiki/Input/output_base_address 中，你可以看到`0x1f0 – 0x1f7  :	Primary Parallel ATA Hard Disk Controller`

在外设与cpu进行交互时，一般会有3种线：控制/状态线，数据线，地址线。在这些端口中，0x1f0用于数据传输，0x1f3~0xf5用于地址传输，0x1f2和0x1f7用于控制，0x1f6兼有控制和地址的作用，另外0x1f7还可以为CPU提供磁盘控制器的状态信息。
不过你不用担心，我们的会尽可能避免大家在太低层的地方花费较多的时间，所以以下提供读取硬盘的方法：（copy自jos）

```c
void
waitdisk(void)
{
    // wait for disk reaady
    while ((inb(0x1F7) & 0xC0) != 0x40)
        // do nothing;
}

void
readsect(void \*dst, uint32_t offset)
{
    // wait for disk to be ready
    waitdisk();

    outb(0x1F2, 1);     // count = 1
    outb(0x1F3, offset);	//address = offset | 0xe0000000
    outb(0x1F4, offset >> 8);
    outb(0x1F5, offset >> 16);
    outb(0x1F6, (offset >> 24) | 0xE0);
    outb(0x1F7, 0x20);  // cmd 0x20 - read sectors

    // wait for disk to be ready
    waitdisk();

    // read a sector
    insl(0x1F0, dst, SECTSIZE/4);
}
```

在完成了loader之后，你便可以跳转到内核了。

### 串口输出

串口用于控制台的输出，对应的端口地址为0x3f8 ~ 0x3ff。串口的初始化和判断空闲的代码如下：

```c
#define PORT 0x3f8   /* COM1 */

void init_serial() {
   outb(PORT + 1, 0x00);
   outb(PORT + 3, 0x80);
   outb(PORT + 0, 0x03);
   outb(PORT + 1, 0x00);
   outb(PORT + 3, 0x03);
   outb(PORT + 2, 0xC7);
   outb(PORT + 4, 0x0B);
}

int is_serial_idle() {
   return inb(PORT + 5) & 0x20;
}
```

你不必掌握每个端口IO的具体含义，只需要知道 init_serial 完成了初始化工作，而 serial_idle 则用于判断对应的端口是否处于空闲状态。当串口处于空闲状态时，则可以通过 out 指令将一个字符输出到该端口完成一次输出。

[https://en.wikipedia.org/wiki/COM_(hardware_interface)](https://en.wikipedia.org/wiki/COM_(hardware_interface))
请根据这个说明，参考已提供的代码自行完成串口输出函数。

你**可能**需要自己实现`inb`, `outb`等需要直接使用 x86 指令的函数，也就需要书写内联汇编代码，[OSDev: Inline Assembly Examples](http://wiki.osdev.org/Inline_Assembly/Examples)有一个份内联汇编的常用样例(cheat sheet!)，[GCC-Inline-Assembly-HOWTO](https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)对于理解内联汇编语法很有帮助。

### 实现printk

从功能上来讲，printk与printf并没有任何区别，它们的作用都是格式化输出。唯一的区别是：printk工作在内核空间，printf工作在用户空间。目前并没有操作系统内核的概念，但这不影响你使用printk。

printk可以接收不固定数目的参数(但至少要有一个)，gcc会把这些参数从右到左压入堆栈。具体形式请自行查找资料，至于如何使用第二个以后的参数，相信聪明的你会想到办法的。

建议先将 printk 接收的格式化字符串转化为字符串常量，你需要实现%d, %x, %s, %c四种格式转换说明符,，然后调用你自己封装好的输出函数将实际的字符串输出（具体输出到哪里请自行决定，你可以输出到串口，也可以输出到屏幕）

我们为大家提供了测试代码：

```c
printk("Printk test begin...\n");
printk("the answer should be:\n");
printk("#######################################################\n");
printk("Hello, welcome to OSlab! I'm the body of the game. ");
printk("Bootblock loads me to the memory position of 0x100000, and Makefile also tells me that I'm at the location of 0x100000. ");
printk("~!@#$^&*()_+`1234567890-=...... ");
printk("Now I will test your printk: ");
printk("1 + 1 = 2, 123 * 456 = 56088\n0, -1, -2147483648, -1412505855, -32768, 102030\n0, ffffffff, 80000000, abcdef01, ffff8000, 18e8e\n");
printk("#######################################################\n");
printk("your answer:\n");
printk("=======================================================\n");
printk("%s %s%scome %co%s", "Hello,", "", "wel", 't', " ");
printk("%c%c%c%c%c! ", 'O', 'S', 'l', 'a', 'b');
printk("I'm the %s of %s. %s 0x%x, %s 0x%x. ", "body", "the game", "Bootblock loads me to the memory position of",
	0x100000, "and Makefile also tells me that I'm at the location of", 0x100000);
printk("~!@#$^&*()_+`1234567890-=...... ");
printk("Now I will test your printk: ");
printk("%d + %d = %d, %d * %d = %d\n", 1, 1, 1 + 1, 123, 456, 123 * 456);
printk("%d, %d, %d, %d, %d, %d\n", 0, 0xffffffff, 0x80000000, 0xabcedf01, -32768, 102030);
printk("%x, %x, %x, %x, %x, %x\n", 0, 0xffffffff, 0x80000000, 0xabcedf01, -32768, 102030);
printk("=======================================================\n");
printk("Test end!!! Good luck!!!\n");
```

实现了printk后, 你可以使用它帮助你调试代码，比如在游戏中输出变量的值.

## 阶段 2 游戏：中断与显示

### 硬件中断

游戏需要两种最基本的中断: 时间中断和键盘中断。为了接受和处理这两种中断，除了填写 IDT 以外，还需要对相关硬件进行初始化设置。下面简要地介绍如何初始化相关的硬件。

#### 中断控制器

Intel 80386 需要[可编程中断控制器(Programmable Interrupt Controller, PIC)](https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller)的支持，才能响应多种外部设备的中断。qemu 使用 8259 中断控制器，在 qemu 控制台中，输入如下命令可以进行验证：

```
(qemu) help info pic
info pic  -- show i8259 (PIC) state
```

在 qemu 的控制台中使用`info pic`查看 PIC 的状态：

```
(qemu) info pic
pic0: irr=15 imr=b8 isr=00 hprio=0 irq_base=08 rr_sel=0 elcr=00 fnm=0
pic1: irr=40 imr=8e isr=00 hprio=0 irq_base=70 rr_sel=0 elcr=0c fnm=0
```

其中，需要关心的是 imr 和 irq_base。 imr 即 Interrupt Mask Register ，是中断位的掩码，为 1 时对应引脚的中断无效（一个 8259 有 8 个中断引脚）。 irq_base 是偏移量，中断引脚的编号加上 irq_base，才是用来查询中断描述符表(IDT)的下标。
每个中断引脚对应的中断事件可以在[OSDev Interrupts 条目](http://wiki.osdev.org/Interrupts#General_IBM-PC_Compatible_Interrupt_Information)上查到，这里列出目前需要的两个中断：

|IRQ|Description|
|---|-----------|
|0|Programmable Interrupt Timer Interrupt|
|1|Keyboard Interrupt|

这里需要注意的是，以时间中断为例， IRQ(0H) + irq_base(08H) = 08H，这个编号在 IDT 中属于 Intel 保留的中断，对应 Double Fault。所以在开启中断前需要对 PIC 进行初始化，主要工作如下：

1. 设置需要的中断屏蔽
2. 设置中断号偏移量等属性

考虑到 8259 的各种端口的使用不是实验的重点，所以提供一份~~流行的~~初始化 8259 控制器的代码，请自行封装成函数并在合适的地方调用它：

```c
#define IO_PIC1 0x20
#define IO_PIC2 0xA0
#define IRQ_OFFSET 0x20
#define IRQ_SLAVE 2

// modify interrupt masks
outb(IO_PIC1 + 1, 0xFF);
outb(IO_PIC2 + 1, 0xFF);

// Set up master (8259A-1)

// ICW1:  0001g0hi
//    g:  0 = edge triggering, 1 = level triggering
//    h:  0 = cascaded PICs, 1 = master only
//    i:  0 = no ICW4, 1 = ICW4 required
outb(IO_PIC1, 0x11);

// ICW2:  Vector offset
outb(IO_PIC1+1, IRQ_OFFSET);

// ICW3:  bit mask of IR lines connected to slave PICs (master PIC),
//        3-bit No of IR line at which slave connects to master(slave PIC).
outb(IO_PIC1+1, 1 << IRQ_SLAVE);

// ICW4:  000nbmap
//    n:  1 = special fully nested mode
//    b:  1 = buffered mode
//    m:  0 = slave PIC, 1 = master PIC
//	  (ignored when b is 0, as the master/slave role
//	  can be hardwired).
//    a:  1 = Automatic EOI mode
//    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
outb(IO_PIC1+1, 0x1);

// Set up slave (8259A-2)
outb(IO_PIC2, 0x11);              // ICW1
outb(IO_PIC2 + 1, IRQ_OFFSET + 8);// ICW2
outb(IO_PIC2 + 1, IRQ_SLAVE);     // ICW3
// NB Automatic EOI mode doesn't tend to work on the slave.
// Linux source code says it's "to be investigated".
outb(IO_PIC2 + 1, 0x01);          // ICW4

// OCW3:  0ef01prs
//   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
//    p:  0 = no polling, 1 = polling mode
//   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
outb(IO_PIC1, 0x68);             /* clear specific mask */
outb(IO_PIC1, 0x0a);             /* read IRR by default */

outb(IO_PIC2, 0x68);             /* OCW3 */
outb(IO_PIC2, 0x0a);             /* OCW3 */
```

上述代码头两行out指令将所有中断都屏蔽了，你可以直接在这里将`0xFF`修改成你需要的屏蔽模式（至少取消键盘和时钟中断的屏蔽），也可以在别的地方下面这样迭代地修改：

```c
uint8_t mask = inb(IO_PICX + 1);
outb(IO_PICX + 1, mask ^ BIT_FOR_THIS_IRQ);
```

#### 时钟中断

时钟(Programmable Interval Timer, PIT)也需要进行一些初始化工作，主要目的是设置频率。详细信息可以参考 http://wiki.osdev.org/Programmable_Interval_Timer ，这里做简单的介绍。

PIT 有三个 channel 产生脉冲，其中 channel 0 与 IRQ 0 直接相连，所以我们需要的是 channel 0 的脉冲。 [PIT 的端口表](http://wiki.osdev.org/Programmable_Interval_Timer#I.2FO_Ports)如下：

|I/O port|Usage|
|--------|-----|
|0x40|Channel 0 data port (read/write)|
|0x41|Channel 1 data port (read/write)|
|0x42|Channel 2 data port (read/write)|
|0x43|Mode/Command register (write only, a read is ignored)|

下面用 C 代码演示基本的初始化步骤：

```c
#define PORT_CH_0 0x40
#define PORT_CMD 0x43
#define PIT_FREQUENCE 1193182
#define HZ 100

union CmdByte {
  struct {
    uint8_t present_mode : 1;
    uint8_t operate_mode : 3;
    uint8_t access_mode  : 2;
    uint8_t channel      : 2;
  };
  uint8_t val;
};

union CmdByte mode = {
  .present_mode = 0,  // 16-bit binary
  .operate_mode = 2,  // rate generator, for more accuracy
  .access_mode  = 3,  // low byte / high byte, see below
  .channel      = 0,  // use channel 0
};

int counter = PIT_FREQUENCE / HZ
outb(PORT_CMD, mode.val);
outb(PORT_CH_0, counter & 0xFF);         // access low byte
outb(PORT_CH_0, (counter >> 8) & 0xFF);  // access high byte
```

与 8295 一样，请自行封装该代码，在内核中你认为合适的地方调用，时钟的频率`HZ`也可以视具体情况调整。

#### 键盘中断

键盘中断没有什么需要初始化的，只需要发生键盘中断后，在对应的中断处理程序里，用`inb(0x60)`获取键盘吗进行相应的操作即可。键盘中断具体采取什么行为与你的系统架构和游戏设计有关。可以参考 PA 的打字小游戏和 sdlpal 。

### 图像输出

由于实验要求在 VGA 图形模式下制作一个小游戏，所以首先要决定使用何种图形模式，并做相应的设置。

常规情况下，我们可以使用 320 x 200 x 256 色的标准 VGA 显式模式。PA 的打字小游戏和 sdlpal 也是在这种模式下显式图像的，所以你们应该也很清楚这种模式存在调色版这种东西，下图是默认情况下调色板的 256 种颜色：

![img](assets/qemu-vga.png)

如果你们的游戏只有一些简单的几何体和字符，那么这种模式和默认的调色板就够用了，但是如果需要使用图片素材，则可能需要修改调色板，在 32 位保护模式下，只能通过直接的端口 IO 进行替换，而且如果要同时呈现两张图片的话，则比较困难。

qemu 2.0.0 支持 vbe 3.0 扩展，扩展提供了更多高分辨率的显式模式和 24 位真彩色的支持。关于如何设置扩展的显示模式，可以参考[VESA Functions](http://wiki.osdev.org/Getting_VBE_Mode_Info#VESA_Functions)。由于`int 10H`等 BIOS 中断只能在 16 位模式下使用，所以设置模式也只能在 boot loader 的早期进行。然而从 vbe 2.0 往后，官方不再规定统一的模式编号（不再分配新的模式号，旧的模式号不需要兼容），一张显卡支持哪些模式，需要获得 Controller Info 进而获得 Mode Info 数组进行查询，在 512B 的 boot loader 中实现这些功能是比较困难的，或者你可以设计两段 boot loader，延长位于 16 位实模式下的时间。

一个取巧的策略是，虽然旧的模式官方不要求兼容，但是实际上也没谁会没事找事去不兼容，所以可以从[这里](https://en.wikipedia.org/wiki/VESA_BIOS_Extensions#VBE_mode_numbers)找到一些通用的模式编号，试出可用的模式。比如，在 qemu 2.0.0 上，模式 800 x 600 x 24-bit (对应编号0115H) 就确实是可用的，显示图片的效果如下：

![img](assets/qemu-vesa.png)

一个额外需要注意的问题就是显存的位置。做过 PA 的各位都知道标准 VGA 模式的显存地址从 0xA0000 开始，但是 vbe 模式则没有统一规定。所以还是需要根据上面提供的链接去获取 Mode Info。从[Memory Map](http://wiki.osdev.org/Memory_Map_(x86)#Overview)中查看在 1MB 内存中哪些部分可以用来存放数据，然后内核和 boot loader 互相约定一个相同的物理地址当做 Mode Info 的地址，然后在内核初始化时用 Mode Info 的 physbase 域确定显存的**物理地址**。

## 补充：Makefile 和调试

这里提供一份参考的 Makefile、Boot Sector制作脚本。

Makefile:

```Makefile
BOOT   := boot.bin
KERNEL := kernel.bin
IMAGE  := disk.bin

CC      := gcc
LD      := ld
OBJCOPY := objcopy
DD      := dd
QEMU    := qemu-system-i386
GDB     := gdb

CFLAGS := -Wall -Werror -Wfatal-errors -MD
CFLAGS += -std=gnu11 -m32 -c
CFLAGS += -I .
CFLAGS += -O0
CFLAGS += -fno-builtin
CFLAGS += -fno-stack-protector
CFLAGS += -ggdb3

QEMU_OPTIONS := -serial stdio -d int
QEMU_OPTIONS += -monitor telnet:127.0.0.1:1111,server,nowait

QEMU_DEBUG_OPTIONS := -S
QEMU_DEBUG_OPTIONS += -s

GDB_OPTIONS := -ex "target remote 127.0.0.1:1234"
GDB_OPTIONS += -ex "symbol $(KERNEL)"

OBJ_DIR        := obj
LIB_DIR        := lib
BOOT_DIR       := boot
KERNEL_DIR     := kernel
OBJ_LIB_DIR    := $(OBJ_DIR)/$(LIB_DIR)
OBJ_BOOT_DIR   := $(OBJ_DIR)/$(BOOT_DIR)
OBJ_KERNEL_DIR := $(OBJ_DIR)/$(KERNEL_DIR)

LD_SCRIPT := $(shell find $(KERNEL_DIR) -name "*.ld")

LIB_C := $(wildcard $(LIB_DIR)/*.c)
LIB_O := $(LIB_C:%.c=$(OBJ_DIR)/%.o)

BOOT_S := $(wildcard $(BOOT_DIR)/*.S)
BOOT_C := $(wildcard $(BOOT_DIR)/*.c)
BOOT_O := $(BOOT_S:%.S=$(OBJ_DIR)/%.o)
BOOT_O += $(BOOT_C:%.c=$(OBJ_DIR)/%.o)

KERNEL_C := $(shell find $(KERNEL_DIR) -name "*.c")
KERNEL_S := $(wildcard $(KERNEL_DIR)/*.S)
KERNEL_O := $(KERNEL_C:%.c=$(OBJ_DIR)/%.o)
KERNEL_O += $(KERNEL_S:%.S=$(OBJ_DIR)/%.o)

$(IMAGE): $(BOOT) $(KERNEL)
	@$(DD) if=/dev/zero of=$(IMAGE) count=10000         > /dev/null # 准备磁盘文件
	@$(DD) if=$(BOOT) of=$(IMAGE) conv=notrunc          > /dev/null # 填充 boot loader
	@$(DD) if=$(KERNEL) of=$(IMAGE) seek=1 conv=notrunc > /dev/null # 填充 kernel, 跨过 mbr

$(BOOT): $(BOOT_O)
	$(LD) -e start -Ttext=0x7C00 -m elf_i386 -nostdlib -o $@.out $^
	$(OBJCOPY) --strip-all --only-section=.text --output-target=binary $@.out $@
	@rm $@.out
	ruby mbr.rb $@

$(OBJ_BOOT_DIR)/%.o: $(BOOT_DIR)/%.S
	@mkdir -p $(OBJ_BOOT_DIR)
	$(CC) $(CFLAGS) -Os $< -o $@

$(OBJ_BOOT_DIR)/%.o: $(BOOT_DIR)/%.c
	@mkdir -p $(OBJ_BOOT_DIR)
	$(CC) $(CFLAGS) -Os $< -o $@

$(KERNEL): $(LD_SCRIPT)
$(KERNEL): $(KERNEL_O) $(LIB_O)
	$(LD) -m elf_i386 -Ttext=0x100000 -nostdlib -o $@ $^ $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)

$(OBJ_LIB_DIR)/%.o : $(LIB_DIR)/%.c
	@mkdir -p $(OBJ_LIB_DIR)
	$(CC) $(CFLAGS) $< -o $@

$(OBJ_KERNEL_DIR)/%.o: $(KERNEL_DIR)/%.[cS]
	mkdir -p $(OBJ_DIR)/$(dir $<)
	$(CC) $(CFLAGS) $< -o $@

DEPS := $(shell find -name "*.d")
-include $(DEPS)

.PHONY: qemu debug gdb clean

qemu: $(IMAGE)
	$(QEMU) $(QEMU_OPTIONS) $(IMAGE)

# Faster, but not suitable for debugging
qemu-kvm: $(IMAGE)
	$(QEMU) $(QEMU_OPTIONS) --enable-kvm $(IMAGE)

debug: $(IMAGE)
	$(QEMU) $(QEMU_DEBUG_OPTIONS) $(QEMU_OPTIONS) $(IMAGE)

gdb:
	$(GDB) $(GDB_OPTIONS)

clean:
	@rm -rf $(OBJ_DIR) 2> /dev/null
	@rm -rf $(BOOT)    2> /dev/null
	@rm -rf $(KERNEL)  2> /dev/null
	@rm -rf $(IMAGE)   2> /dev/null
```

Boot Sector 制作脚本(Ruby 版本，你可以用任何语言来制作)：

```ruby
#!/usr/bin/env ruby

obj = open(ARGV[0], "ab")

if obj.size <= 510
    fill = 510 - obj.size
    fill.times { obj.write("\x00") }
    obj.write("\x55")
    obj.write("\xaa")
else
    puts "#{ARGV[0]}'s size is too large"
end
```

这份 Makefile 中包含了一些调试功能，比如：

1. GDB调试：在一个终端输入`make debug`启动 qemu，在另一个终端输入`make gdb`启动 gdb 进行调试
1. 启动 qemu 后，在另一个终端输入`telnet 127.0.0.1 1111`登陆 qemu 的控制台，主要使用`info registers`查看 CPU 的完整状态
1. qemu 的 `-serial stdio` 将串口输出到标准输出
1. qemu 的 `-d int` 将打印所有的中断事件，在开中断前可以方便地检查造成 triple fault 的原因
