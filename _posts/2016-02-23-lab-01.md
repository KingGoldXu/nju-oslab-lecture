---
layout: post
title: Lab 01
---

## 阶段 1

### 串口输出

串口用于控制台的输出，对应的端口地址为0x3f8 ~ 0x3ff。串口的初始化和判断空闲的代码如下：

```c
#define PORT 0x3f8   /* COM1 */

void init_serial() {
   outb(PORT + 1, 0x00);
   outb(PORT + 3, 0x80);
   outb(PORT + 0, 0x03);
   outb(PORT + 1, 0x00);
   outb(PORT + 3, 0x03);
   outb(PORT + 2, 0xC7);
   outb(PORT + 4, 0x0B);
}

int is_serial_idle() {
   return inb(PORT + 5) & 0x20;
}
```

你不必掌握每个端口IO的具体含义，只需要知道 init_serial 完成了初始化工作，而 serial_idle 则用于判断对应的端口是否处于空闲状态。当串口处于空闲状态时，则可以通过 out 指令将一个字符输出到该端口完成一次输出。

[https://en.wikipedia.org/wiki/COM_(hardware_interface)](https://en.wikipedia.org/wiki/COM_(hardware_interface))
请根据这个说明，参考已提供的代码自行完成串口输出函数。

你**可能**需要自己实现`inb`, `outb`等需要直接使用 x86 指令的函数，也就需要书写内联汇编代码，[OSDev: Inline Assembly Examples](http://wiki.osdev.org/Inline_Assembly/Examples)有一个份内联汇编的常用样例(cheat sheet!)，[GCC-Inline-Assembly-HOWTO](https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)对于理解内联汇编语法很有帮助。

### 实现printk

从功能上来讲，printk与printf并没有任何区别，它们的作用都是格式化输出。唯一的区别是：printk工作在内核空间，printf工作在用户空间。目前并没有操作系统内核的概念，但这不影响你使用printk。

printk可以接收不固定数目的参数(但至少要有一个)，gcc会把这些参数从右到左压入堆栈。具体形式请自行查找资料，至于如何使用第二个以后的参数，相信聪明的你会想到办法的。

建议先将 printk 接收的格式化字符串转化为字符串常量，你需要实现%d, %x, %s, %c四种格式转换说明符,，然后调用你自己封装好的输出函数将实际的字符串输出（具体输出到哪里请自行决定，你可以输出到串口，也可以输出到屏幕）

我们为大家提供了测试代码：

```c
printk("Printk test begin...\n");
printk("the answer should be:\n");
printk("#######################################################\n");
printk("Hello, welcome to OSlab! I'm the body of the game. ");
printk("Bootblock loads me to the memory position of 0x100000, and Makefile also tells me that I'm at the location of 0x100000. ");
printk("~!@#$^&*()_+`1234567890-=...... ");
printk("Now I will test your printk: ");
printk("1 + 1 = 2, 123 * 456 = 56088\n0, -1, -2147483648, -1412505855, -32768, 102030\n0, ffffffff, 80000000, abcdef01, ffff8000, 18e8e\n");
printk("#######################################################\n");
printk("your answer:\n");
printk("=======================================================\n");
printk("%s %s%scome %co%s", "Hello,", "", "wel", 't', " ");
printk("%c%c%c%c%c! ", 'O', 'S', 'l', 'a', 'b');
printk("I'm the %s of %s. %s 0x%x, %s 0x%x. ", "body", "the game", "Bootblock loads me to the memory position of",
	0x100000, "and Makefile also tells me that I'm at the location of", 0x100000);
printk("~!@#$^&*()_+`1234567890-=...... ");
printk("Now I will test your printk: ");
printk("%d + %d = %d, %d * %d = %d\n", 1, 1, 1 + 1, 123, 456, 123 * 456);
printk("%d, %d, %d, %d, %d, %d\n", 0, 0xffffffff, 0x80000000, 0xabcedf01, -32768, 102030);
printk("%x, %x, %x, %x, %x, %x\n", 0, 0xffffffff, 0x80000000, 0xabcedf01, -32768, 102030);
printk("=======================================================\n");
printk("Test end!!! Good luck!!!\n");
```

实现了printk后, 你可以使用它帮助你调试代码，比如在游戏中输出变量的值.

## 阶段 2

### 硬件中断

游戏需要两种最基本的中断: 时间中断和键盘中断。为了接受和处理这两种中断，除了填写 IDT 以外，还需要对相关硬件进行初始化设置。下面简要地介绍如何初始化相关的硬件。

#### 中断控制器

Intel 80386 需要[可编程中断控制器(Programmable Interrupt Controller, PIC)](https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller)的支持，才能响应多种外部设备的中断。qemu 使用 8259 中断控制器，在 qemu 控制台中，输入如下命令可以进行验证：

```
(qemu) help info pic
info pic  -- show i8259 (PIC) state
```

在 qemu 的控制台中使用`info pic`查看 PIC 的状态：

```
(qemu) info pic
pic0: irr=15 imr=b8 isr=00 hprio=0 irq_base=08 rr_sel=0 elcr=00 fnm=0
pic1: irr=40 imr=8e isr=00 hprio=0 irq_base=70 rr_sel=0 elcr=0c fnm=0
```

其中，需要关心的是 imr 和 irq_base。 imr 即 Interrupt Mask Register ，是中断位的掩码，为 1 时对应引脚的中断无效（一个 8259 有 8 个中断引脚）。 irq_base 是偏移量，中断引脚的编号加上 irq_base，才是用来查询中断描述符表(IDT)的下标。
每个中断引脚对应的中断事件可以在[OSDev Interrupts 条目](http://wiki.osdev.org/Interrupts#General_IBM-PC_Compatible_Interrupt_Information)上查到，这里列出目前需要的两个中断：

|IRQ|Description|
|---|-----------|
|0|Programmable Interrupt Timer Interrupt|
|1|Keyboard Interrupt|

这里需要注意的是，以时间中断为例， IRQ(0H) + irq_base(08H) = 08H，这个编号在 IDT 中属于 Intel 保留的中断，对应 Double Fault。所以在开启中断前需要对 PIC 进行初始化，主要工作如下：

1. 设置需要的中断屏蔽
2. 设置中断号偏移量等属性

考虑到 8259 的各种端口的使用不是实验的重点，所以提供一份~~流行的~~初始化 8259 控制器的代码，请自行封装成函数并在合适的地方调用它：

```c
#define IO_PIC1 0x20
#define IO_PIC2 0xA0
#define IRQ_OFFSET 0x20
#define IRQ_SLAVE 2

// modify interrupt masks
outb(IO_PIC1 + 1, 0xFF);
outb(IO_PIC2 + 1, 0xFF);

// Set up master (8259A-1)

// ICW1:  0001g0hi
//    g:  0 = edge triggering, 1 = level triggering
//    h:  0 = cascaded PICs, 1 = master only
//    i:  0 = no ICW4, 1 = ICW4 required
outb(IO_PIC1, 0x11);

// ICW2:  Vector offset
outb(IO_PIC1+1, IRQ_OFFSET);

// ICW3:  bit mask of IR lines connected to slave PICs (master PIC),
//        3-bit No of IR line at which slave connects to master(slave PIC).
outb(IO_PIC1+1, 1 << IRQ_SLAVE);

// ICW4:  000nbmap
//    n:  1 = special fully nested mode
//    b:  1 = buffered mode
//    m:  0 = slave PIC, 1 = master PIC
//	  (ignored when b is 0, as the master/slave role
//	  can be hardwired).
//    a:  1 = Automatic EOI mode
//    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
outb(IO_PIC1+1, 0x1);

// Set up slave (8259A-2)
outb(IO_PIC2, 0x11);              // ICW1
outb(IO_PIC2 + 1, IRQ_OFFSET + 8);// ICW2
outb(IO_PIC2 + 1, IRQ_SLAVE);     // ICW3
// NB Automatic EOI mode doesn't tend to work on the slave.
// Linux source code says it's "to be investigated".
outb(IO_PIC2 + 1, 0x01);          // ICW4

// OCW3:  0ef01prs
//   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
//    p:  0 = no polling, 1 = polling mode
//   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
outb(IO_PIC1, 0x68);             /* clear specific mask */
outb(IO_PIC1, 0x0a);             /* read IRR by default */

outb(IO_PIC2, 0x68);             /* OCW3 */
outb(IO_PIC2, 0x0a);             /* OCW3 */
```

上述代码头两行out指令将所有中断都屏蔽了，你可以直接在这里将`0xFF`修改成你需要的屏蔽模式（至少取消键盘和时钟中断的屏蔽），也可以在别的地方下面这样迭代地修改：

```c
uint8_t mask = inb(IO_PICX + 1);
outb(IO_PICX + 1, mask ^ BIT_FOR_THIS_IRQ);
```

#### 时钟中断

时钟(Programmable Interval Timer, PIT)也需要进行一些初始化工作，主要目的是设置频率。详细信息可以参考 http://wiki.osdev.org/Programmable_Interval_Timer ，这里做简单的介绍。

PIT 有三个 channel 产生脉冲，其中 channel 0 与 IRQ 0 直接相连，所以我们需要的是 channel 0 的脉冲。 [PIT 的端口表](http://wiki.osdev.org/Programmable_Interval_Timer#I.2FO_Ports)如下：

|I/O port|Usage|
|--------|-----|
|0x40|Channel 0 data port (read/write)|
|0x41|Channel 1 data port (read/write)|
|0x42|Channel 2 data port (read/write)|
|0x43|Mode/Command register (write only, a read is ignored)|

下面用 C 代码演示基本的初始化步骤：

```c
#define PORT_CH_0 0x40
#define PORT_CMD 0x43
#define PIT_FREQUENCE 1193182
#define HZ 100

union CmdByte {
  struct {
    uint8_t present_mode : 1;
    uint8_t operate_mode : 3;
    uint8_t access_mode  : 2;
    uint8_t channel      : 2;
  };
  uint8_t val;
};

union CmdByte mode = {
  .present_mode = 0,  // 16-bit binary
  .operate_mode = 2,  // rate generator, for more accuracy
  .access_mode  = 3,  // low byte / high byte, see below
  .channel      = 0,  // use channel 0
};

int counter = PIT_FREQUENCE / HZ
outb(PORT_CMD, mode.val);
outb(PORT_CH_0, counter & 0xFF);         // access low byte
outb(PORT_CH_0, (counter >> 8) & 0xFF);  // access high byte
```

与 8295 一样，请自行封装该代码，在内核中你认为合适的地方调用，时钟的频率`HZ`也可以视具体情况调整。

#### 键盘中断

键盘中断没有什么需要初始化的，只需要发生键盘中断后，在对应的中断处理程序里，用`inb(0x60)`获取键盘吗进行相应的操作即可。键盘中断具体采取什么行为与你的系统架构和游戏设计有关。可以参考 PA 的打字小游戏和 sdlpal 。
